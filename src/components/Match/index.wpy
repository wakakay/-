<template>
  <view class="match-article flex-space-between-column">
    <view class="match-article__header flex-space-between-column">
      <text class="text-subtitle match-article__header__title"> {{ bundle.description }} </text><!-- match-article__header__title -->
      <text class="text-body match-article__header__caption"> {{ bundle.operatetip }} </text><!-- match-article__header__caption -->
    </view><!-- match-article__header -->
    <movable-area class="match-article__body" direction="all" id="match__area">
      <movable-view class="match-article__body__sequare-block" wx:for="{{bundle.association}}" wx:for-index="$match$index" wx:for-item="$match$item" wx:key="$match$index" hidden="{{ $match$item.hidden }}" id="square-{{ $match$item.id }}" data-id="{{ $match$item.id }}" data-answer="{{ $match$item.answer }}" direction="all" inertia="{{ true }}" damping="{{40}}" friction="{{4}}" x="{{ $match$item.x }}" y="{{ $match$item.y }}" catchtouchstart="handleSquareStart" catchtouchmove="handleSquareMove" catchtouchend="handleSquareEnd">
        <image class="match-article__body__sequare-block__icon" src="{{ $match$item.imageUrl }}" mode="scaleToFill">
          <image hidden="{{ 'waiting'===$match$item.matchOptionStatu }}" class="match-article__body__sequare-block__icon__judgement-icon" src="../../assets/img/icon-drop-{{ $match$item.matchOptionStatu }}.svg" mode="scaleToFill"></image>
        </image>
      </movable-view>
      <view class="match-article__body__options-wrapper flex-space-between-row">
        <view class="match-article__body__options-wrapper__block" wx:for="{{ bundle.matching }}" wx:for-index="$match$index" wx:for-item="$match$item" wx:key="$match$index">
          <image class="match-article__body__options-wrapper__block__icon" :class="{ sticky: $match$item.answer }" src="{{ $match$item.answer? $match$item.answer: '../../assets/img/icon-drop-waiting.svg' }}" mode="scaleToFill"></image><!-- index 1 -->
          <view class="match-article__body__options-wrapper__block__caption">{{ $match$item.option }}</view>
        </view><!-- match-article__body__options-wrapper__block -->
      </view><!-- match-article__body__options-wrapper -->
    </movable-area><!-- match-article__body -->
  </view><!-- match-article -->
</template>

<script>
  import wepy from 'wepy'
  import { sleep } from '../../utils'

  const LOCATION_SOURCE_X = 76
  const LOCATION_SOURCE_Y = 0

  const LOCATION_LEFT_BOTTOM_X = 0
  const LOCATION_LEFT_BOTTOM_Y = 183

  const LOCATION_RIGHT_BOTTOM_X = 151
  const LOCATION_RIGHT_BOTTOM_Y = 183


  const TOP_DIRECTION = 'TOP'
  const LEFT_DIRECTION = 'LEFT'
  const RIGHT_DIRECTION = 'RIGHT'

  const MOVE_TIME = 0.1
  const JUDGE_TIME = 0.6
  const DISAPPEARED_TIME = 0.6

  export default class Match extends wepy.component {
    props = {
      bundle: {
        type: Object
      },
      offset: {
        type: Number
      }
    } // end props

    data = {
      deadTopLine: 0,
      deadLeftLine: 0,
      deadRightLine: 0,
      deadDivideX: 0,
      matchOptionStatu: 'waiting', // waiting, correct, wrong
      dragging: false,
      squares: [{
        x: 70,
        y: 0,
        id: 'a',
        icon: 'http://wx-small.runwise.cn/image/imageID2208083f20c446b1ad2ae63a8a35.png'
      }, {
        x: 70,
        y: 0,
        id: 'b',
        icon: 'http://wx-small.runwise.cn/image/imageID3afcb49c70344fa9f60ddfe4a962.png'
      }, {
        x: 70,
        y: 0,
        id: 'c',
        icon: 'http://wx-small.runwise.cn/image/imageIDa880dcaeade430b9da12b2a69d2b.png'
      }]
    }

    computed = {
    }

    methods = {
      activateCard(currentCardOffset) {
        // console.log('in activateCard', this.$parent)
        // wx.createSelectorQuery().selectViewport().fields({
        //   size: true,
        // }).exec(([{ width, height }]) => {
        //   console.log('res', width, height)
        //   this.deadTopLine = height - height * 0.1 - 15 - 120 - 120 / 2 - 54
        //   this.deadLeftLine = (width - 279) / 2
        //   this.deadRightLine = width - this.deadLeftLine - 128
        //   this.deadDivideX = (width - this.deadLeftLine * 2) / 2
        //   console.log('deadTopLine', this.deadTopLine)
        //   console.log('deadLeftLine', this.deadLeftLine)
        //   console.log('deadRightLine', this.deadRightLine)
        //   console.log('deadDivideX', this.deadDivideX)
        //   this.$apply()
        // })
        this.deadTopLine = this.$parent.cardHeight - this.$parent.cardTop - 15 - 120 - 120 / 2 - 54
        this.deadLeftLine = (this.$parent.cardWidth - 279) / 2
        this.deadRightLine = this.$parent.cardWidth - this.deadLeftLine - 128
        this.deadDivideX = (this.$parent.cardWidth - this.deadLeftLine * 2) / 2
      }, // activateCard
      handleSquareStart() {
        this.dragging = true
      }, // handleSquareStart
      handleSquareMove() {}, // handleSquareMove
      handleSquareEnd({ currentTarget: { dataset: { id, answer, comIndex } } }) {
        // console.log('id', id, this.$parent.cards[this.$parent.cardSyncCurrent]['association'])
        this.dragging = false
        let mItems = this.$parent.cards[this.$parent.cardSyncCurrent]['association']
        let mTargetIndex = mItems.findIndex(item => item.id===id)
        // console.log('end index', mTargetIndex)
        if (-1===mTargetIndex) return false
        let mQuery = wx.createSelectorQuery().select(`#square-${id}`)
        mQuery.boundingClientRect().exec(([{ left, right, top, bottom, dataset: { comIndex } }]) => {
          // console.log(`query result top: ${top}, bottom: ${bottom}, left: ${left}, right: ${right}`)
          console.log(this.isAttendToWhere({top, left}))
          const mDirection = this.isAttendToWhere({top, left})
          TOP_DIRECTION===mDirection && this.drawnToSource(mTargetIndex)

          LEFT_DIRECTION===mDirection && this.drawnToLeftBottom(mTargetIndex) && sleep(MOVE_TIME).then(() => {
            // console.log('answer', answer)
            this.toggleCorrectOrWrong({ associationOffset: mTargetIndex, flag: 0===answer })
            return sleep(JUDGE_TIME)
          })
            .then(() => {
              this.toggleCorrectOrWrong({ associationOffset: mTargetIndex, flag: 0===answer })
              0===answer && this.$emit('setAssocicationHidden', { componentOffset: this.$index, associationOffset: mTargetIndex, to: 'left' })
              1===answer && this.drawnToSource(mTargetIndex)
            })
            .then(() => {
              if (0!==this.$parent.cards[this.$parent.cardSyncCurrent]['association'].filter(item => false===item.hidden).length) return
              this.$emit('neutralResponse', {
                offset: this.$index,
                  feedbackBundle: this.$parent.cards[this.$parent.cardSyncCurrent]['feedback']
              })
              this.$emit('shuffleAssocicationCard', { componentOffset: this.$index })
            })

          RIGHT_DIRECTION===mDirection && this.drawnToRightBottom(mTargetIndex) && sleep(MOVE_TIME).then(() => {
            // console.log('answer', answer)
            this.toggleCorrectOrWrong({ associationOffset: mTargetIndex, flag: 1===answer })
            return sleep(JUDGE_TIME)
          })
            .then(() => {
              this.toggleCorrectOrWrong({ associationOffset: mTargetIndex, flag: 1===answer })
              0===answer && this.drawnToSource(mTargetIndex)
              1===answer && this.$emit('setAssocicationHidden', { componentOffset: this.$index, associationOffset: mTargetIndex, to: 'right' })
            })
            .then(() => {
              if (0!==this.$parent.cards[this.$parent.cardSyncCurrent]['association'].filter(item => false===item.hidden).length) return
              this.$emit('neutralResponse', {
                  offset: this.$index,
                  feedbackBundle: this.$parent.cards[this.$parent.cardSyncCurrent]['feedback']
              })
              this.$emit('shuffleAssocicationCard', { componentOffset: this.$index })
            })

          this.$apply()
        })
      } // end handleSquareEnd
    } // end methods

    toggleCorrectOrWrong({ associationOffset, flag }) {
      // console.log(`tend to change ${flag}, ${associationOffset}`)
      return this.$emit('toggleAssocicationMatchOptionStatu', { componentOffset: this.$index, associationOffset, flag })
      if ('waiting'!==this.matchOptionStatu) {
        this.matchOptionStatu = 'waiting'
        return this.$apply()
      }
      let mValue = flag ? 'correct': 'wrong'
      this.matchOptionStatu = mValue
      return this.$apply()
    } // end showCorrectOrWrong

    drawnToLeftBottom(squareOffset) {
        // console.log('move left bottom!!!!', squareOffset)
        this.$emit('setAssocicationLocation', {
          componentOffset: this.$index,
          associationOffset: squareOffset,
          x: LOCATION_LEFT_BOTTOM_X,
          y: LOCATION_LEFT_BOTTOM_Y
        })
        return true
    } // drawnToLeftBottom

    drawnToRightBottom(squareOffset) {
      // console.log('move right bottom!!!!', squareOffset)
      this.$emit('setAssocicationLocation', {
        componentOffset: this.$index,
        associationOffset: squareOffset,
        x: LOCATION_RIGHT_BOTTOM_X,
        y: LOCATION_RIGHT_BOTTOM_Y
      })
      return true
    } // drawnToRightBottom

    drawnToSource(squareOffset) {
      console.log('move source!!!', squareOffset)
      this.$emit('setAssocicationLocation', {
        componentOffset: this.$index,
        associationOffset: squareOffset,
        x: LOCATION_SOURCE_X,
        y: LOCATION_SOURCE_Y - Math.random() * 0.0001
      })
      return true
    } // drawnToRightBottom

    isAttendToWhere({top, left}) {
      // console.log(`now top: ${top}, now left: ${left}, is top: ${top<this.deadTopLine}`)
      if (top < this.deadTopLine) return TOP_DIRECTION
      if (left <= this.deadDivideX) return LEFT_DIRECTION
      return RIGHT_DIRECTION
    } // isAttendToLeftOrRightCorner
  }
</script>

<style lang="less">
  .match-article {
    width: 100%;
    height: 100%;
    align-items: center;
    background-color: #FFF;
  }
  .match-article__header {
    flex: 1;
    align-items: center;
    /*background-color: #B2F3F2;*/
  }
    .match-article__header__title {
      max-width: 600rpx;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-basis: 156rpx;
      flex-grow: 1;
      flex-shrink: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
    }
    .match-article__header__title {
      text-align: center;
      white-space: normal;
    }
    .match-article__header__caption {
      flex-basis: 56rpx;
      flex-grow: 1;
      flex-shrink: 1;
      margin-top: 32rpx;
      margin-bottom: auto;
    }
  .match-article__body {
    width: 279px;
    height: 359px;
    /*background-color: #F6D5C3;*/
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }

  .match-article__body__sequare-block {
    width: 128px;
    height: 120px;
    background-color: #F6DDBF;
    border-radius: 24px;
    overflow: hidden;
    z-index: 99;
  }

    .match-article__body__sequare-block__icon {
      width: inherit;
      height: inherit;
      position: relative;
    }
    .match-article__body__sequare-block__icon__judgement-icon {
      width: 32px;
      height: 32px;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      margin: auto;
      animation: fadeOutUp .9s ease-in-out .1s;
    }

  .match-article__body__options-wrapper {
    width: inherit;
    align-items: flex-end;
    z-index: 9;
  }

  .match-article__body__options-wrapper__block {
    width: 128px;
    height: 120px;
    position: relative;
    bottom: 54px;
    background-color: #FFF4EF;
    border: 2px dashed #FFBCA1;
    border-radius: 24px;
    /*overflow: hidden;*/
  }
  .match-article__body__options-wrapper__block__icon {
      width: 32px;
      height: 32px;
      position: absolute;
      margin: auto;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      transition: all .2s ease-in;
    }
    .match-article__body__options-wrapper__block__icon.sticky {
      width: inherit;
      height: inherit;
      border-radius: 24px;
    }
    .match-article__body__options-wrapper__block__caption {
      width: inherit;
      height: 54px;
      /*background-color: #FF6DB5;*/
      position: absolute;
      top: 120px;
      left: 0;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      color: #5E6C84;
      font-family: PingFangSC-Regular;
      font-size: 28rpx
    }
</style>
