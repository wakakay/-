<template>
    <view class="sorting-article">
        <jn-header :title.sync="headerTitle"></jn-header>
        <view class="sorting-article__description">{{ bundle.description }}</view>

        <view class="order-article-body-orderitem__wrapper" style="height: {{ 176 * sourceList.length + 120 }}rpx;">
            <view @tap.stop="handleSelect" wx:for="{{sourceList}}" wx:for-index="$morder$index"
                  wx:for-item="$morder$item" wx:key="$morder$index" data-id="{{ $morder$item.id }}"
                  data-status="{{ cardStatus }}" data-card-i-d="{{ bundle.id }}"
                  data-ability-skill="{{ bundle.abilitySkill }}" data-ability-group="{{ bundle.abilityGroup }}"
                  data-message="{{ $morder$item.option }}" data-weight="{{ $morder$item.weight }}"
                  data-mark="{{ bundle.score }}" class="order-article-body-orderitem"
                  style="top: {{ 176 * mapper[$morder$item.id]['order'] }}rpx;">
                <view class="order-article-body-orderitem-num" wx:if="{{ mapper[$morder$item.id]['isAnswer'] }}">
                    {{mapper[$morder$item.id]['order'] + 1}}
                </view>
                <view class="order-article-body-orderitem-num null" wx:else></view>
                <view class="order-article-body-orderitem-text">{{ $morder$item.option }}</view>
            </view>
        </view><!-- wrapper -->

    </view><!-- article -->
    <!-- capture-catch:touchstart="handleTouchBoxStart" capture-catch:touchmove="handleTouchBoxMove" capture-catch:touchend="handleTouchBoxEnd" -->
    <!-- {{ 0===yTouchStart? 'display: flex;': 'transform: translate3d(0,'+ (yTouchDistance > 0? yTouchDistance: 0) + 'px, 0);' }} -->
    <view hidden="{{ !isModalShow }}" class="flex-end-column sorting-response-box-wrapper" @tap.stop="handleCloseModal">
        <view
            class="flex-space-between-column sorting-response-box {{ isFeedbackBoxShow? 'open': 'close' }} {{ 0===yTouchStart? 'touchend': 'touching' }} {{feedbackType=='right'?'sorting-response-right':'sorting-response-wrong'}}"
            style="" @tap.stop="handleCatchInvalidModalTouch">
            <view
                class="sorting-response-box__title-before {{feedbackType=='right'?'':'sorting-response-box__title-before-wrong'}}"></view>
            <text class="sorting-response-box__title">{{ feedbackTitle }}</text>
            <view class="sorting-response-box__caption">{{ feedbackDescription }}</view>
            <view class="sorting-response-box__footer {{equipmentModel?'iphoneX':''}}" @tap.stop="handleTurnPage">
                {{currentPracticeOffset+1===practicesLength?'完成':'下一题'}}
            </view>
        </view><!-- box -->
    </view><!-- wrapper -->
</template>

<script>
    import wepy from 'wepy'
    import {
        getStore,
        connect
    } from "wepy-redux"
    import {initializationDeligate, redirectToPractice, sleep} from '../../utils'
    import {card as cardApi} from '../../api'
    import header from '../../components/common/header'

    export default class Sorting extends wepy.page {
        components = {
            'jn-header': header
        } // end components

        data = {
            headerTitle: '',
            token: 'defaultToken',
            bundle: null,
            practiceCount: 0,
            equipmentModel: false,
            courseID: 'defaultCourseID',
            senceID: 'defaultSenceID',
            requestFlag: 0,

            isFeedbackBoxShow: false, // 控制弹窗是否出现
            isModalShow: false, // 遮罩(底色)层是否出现
            isModalTouching: false, // 是否触摸弹窗
            yTouchStart: 0, // 手指触摸开始的y轴
            yTouchDistance: 0, // 手指触摸弹窗移动距离
            description: '这个是测试场景描述文案，内容尽量不要超过四行，这个是测试场景描述文案，内容尽量不要超过四行，以下请按顺序选择正确选择～',
            feedbackTitle: 'defaultFeedbackTitle',
            feedbackDescription: 'defaultFeedbackDescription',
            feedbackType: 'wrong',

            trueSequence: '', // end trueSequence
            sourceList: [], // end sourceList
            orderList: [], // end orderList
            mapper: {}
        }

        onLoad() {
            let self = this
            self.trueSequence = 'wrong'
            self.sourceList = []
            self.orderList = []
            self.mapper = {}
        }

        onShow() {
            let self = this
            initializationDeligate({initializeFunc: self.initialize.bind(self)})
        }

        methods = {
            handleTurnPage() {
                // console.log('turn page')
                this.triggerFeedback(false)
                    .then(() => {
                        redirectToPractice(this.currentPracticeOffset + 1)
                        this.$apply()
                    })
            }, // end handleTurnPage
            handleSelect({currentTarget: {dataset: {comIndex, status, id: optionID, feedback, feedbackneutral, abilitySkill, abilityGroup, weight, message, mark, cardID}}}) {
                let mMapper = JSON.parse(JSON.stringify(this.mapper))
                let mOrderList = JSON.parse(JSON.stringify(this.orderList))
                let mOffset = mOrderList.findIndex(item => optionID === item.optionID)
                if (!mOrderList[mOffset]['isAnswer']) {
                    // console.log('false to true')
                    let mTmp = JSON.parse(JSON.stringify(mOrderList[mOffset]))
                    mOrderList.splice(mOffset, 1)
                    let mTarget = mOrderList.filter(item => item.isAnswer).length
                    mOrderList.splice(mTarget, 0, {...mTmp, isAnswer: true})
                } else {
                    // console.log('true to false')
                    for (let [index, item] of mOrderList.entries()) {
                        if (index >= mOffset) mOrderList[index]['isAnswer'] = false
                    }
                }
                for (let [index, item] of mOrderList.entries()) {
                    mMapper[item.optionID] = {order: index, isAnswer: item.isAnswer}
                }
                // this.$emit('reorder', { componentOffset: comIndex, orderList: mOrderList, mapper: mMapper })
                this.orderList = mOrderList
                this.mapper = mMapper
                const mTendToFeedback = mOrderList.filter(item => item.isAnswer).length === mOrderList.length
                // 上报选择内容
                let mQuery = JSON.stringify({
                    sourceList: this.sourceList.map(item => ({id: item.id, weight: item.weight})),
                    orderList: this.orderList.map(item => ({id: item.optionID, weight: item.weight}))
                })
                null != mark && cardApi.sendCardScore({
                    token: this.token,
                    senceID: this.senceID,
                    cardID,
                    message,
                    score: mark,
                    abilityGroup,
                    abilitySkill,
                    json: mQuery
                })
                    .then(() => console.log('练习上报成功'))
                    .catch(error => console.log('练习上报失败', error))

                if (!mTendToFeedback) return false // 如果没有选完，不往下
                const mFlag = this.checkOrder(mOrderList) // 判断顺序是否正确
                const mFeedback = this.bundle.feedbackType3[mFlag ? 'right' : 'wrong']
                // console.log('feedback', mFlag, mFeedback)
                this.feedbackType = mFeedback.type
                this.triggerFeedback(true) // 显示弹窗
                this.feedbackTitle = mFeedback['title']
                this.feedbackDescription = mFeedback['description']
            }, // end handleSelect

            handleCatchInvalidModalTouch() {
                return false
            }, // end handleCatchInvalidModalTouch

            handleTouchBoxStart({changedTouches: [{clientY}]}) {
                this.yTouchStart = clientY
            }, // end handlef

            handleTouchBoxMove({changedTouches: [{clientY}]}) {
                this.yTouchDistance = clientY - this.yTouchStart
            }, // end handleTouchBoxMove

            handleTouchBoxEnd() {
                this.yTouchStart = 0
                this.yTouchDistance = 0
            }, // end handleTouchBoxEnd

            handleCloseModal() {
                this.triggerFeedback(false)
            } // end handleCloseModal
        } // end methods

        initialize() {
            const {
                user: {token, equipmentModel},
                practices: {
                    requestFlag,
                    currentSectionOffset,
                    courseID,
                    senceID,
                    sections
                },
                sences:{
                    currentName
                }
            } = getStore().getState()
            this.token = token
            this.bundle = sections[currentSectionOffset]
            this.currentPracticeOffset = currentSectionOffset
            this.practiceCount = sections.length
            this.equipmentModel = equipmentModel.startsWith('iPhone X')
            this.courseID = courseID
            this.senceID = senceID
            this.requestFlag = requestFlag

            this.isModalShow = false
            this.isFeedbackBoxShow = false
            this.trueSequence = this.bundle.select.map(item => item.id).join(',')

            let sourceList = (function (aArr) {
                let iLength = aArr.length,
                    i = iLength,
                    mTemp,
                    iRandom

                while (i--) {
                    if (i !== (iRandom = Math.floor(Math.random() * iLength))) {
                        mTemp = aArr[i]
                        aArr[i] = aArr[iRandom]
                        aArr[iRandom] = mTemp
                    }
                }

                return aArr
            })(this.bundle.select)
            let orderList = sourceList.map(blob => ({optionID: blob.id, isAnswer: false, weight: blob.weight}))
            let mapper = {}
            for (let [index, blob] of orderList.entries()) {
                mapper[blob.optionID] = {order: index, isAnswer: blob.isAnswer}
            } // end for
            this.sourceList = sourceList
            this.orderList = orderList
            this.mapper = mapper

            /*wepy.setNavigationBarTitle({
                title: `即学即练 ${this.currentPracticeOffset - 0 + 1}/${this.practiceCount}`
            })*/
            this.headerTitle = `即学即练 ${this.currentPracticeOffset - 0 + 1}/${this.practiceCount}`
            wepy.$instance.globalData.getLoadHuilder({pageTheme: currentName}) // ga统计
            this.$apply()
        }

        checkOrder(pArr) {
            if ('' === this.trueSequence) return false
            if (0 === pArr.length) return false
            return this.trueSequence === pArr.map(item => item.optionID).join(',')
        } // end checkOrder

        triggerFeedback(flag) {
            let mFlag = flag === true
            if (mFlag) {
                this.isModalShow = mFlag
                return sleep(0.2)
                    .then(() => {
                        this.isFeedbackBoxShow = mFlag
                        this.$apply()
                    })
            } // end if

            this.isFeedbackBoxShow = mFlag
            return sleep(0.2)
                .then(() => {
                    this.isModalShow = mFlag
                    this.$apply()
                })

        } // end triggerFeedback

    }
</script>

<style lang="less">
  .sorting-article {
    width: 100%;
    height: 100%;
    padding-top: 80rpx;
    overflow: scroll;
    box-sizing: border-box;
    background-color: #FFF;
    animation: fadeIn 1.2s;
    -webkit-animation: fadeIn 1.2s;
  }

  ::-webkit-scrollbar {
    width: 0;
    height: 0;
    background-color: transparent;
    color: transparent;
  }

  .sorting-article__description {
    width: 654rpx;
    max-height: 156rpx;
    background-color: #FFF;
    margin: 0 auto 88rpx;
    font-family: PingFang-SC-Medium;
    font-size: 32rpx;
    color: #14292C;
    text-align: justify;
    line-height: 52rpx;
  }

  .order-article-body-orderitem__wrapper {
    width: 702rpx;
    position: relative;
  }
  .order-article-body-orderitem {
      height: 144rpx;
      width: 654rpx;
      margin: 0 48rpx 32rpx 48rpx;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      background-color: #FFF;
      box-shadow: 0 2px 10px 0 rgba(0, 0, 0, 0.13);
      border-radius: 16rpx;
      transition: all .15s ease-in;
      text-align: left;
      position: absolute;
      top: 0;
      left: 0;
  }
  .order-article-body-orderitem.actived {
      -webkit-animation: fadeInLeft .5s ease-out 0s;
      -o-animation: fadeInLeft .5s ease-out 0s;
      animation: fadeInLeft .5s ease-out 0s;
  }
  /*.order-article-body-orderitem:active {
      animation: shrinkOut .2s;
  }
  */
  .order-article-body-orderitem.shrink-out {
      animation: fadeOutLeft .5s;
  }
  .order-article-body-orderitem.falling {
      animation: slideOutDown .7s;
  }
  .order-article-body-orderitem-num{
      width: 48rpx;
      height: 48rpx;
      border-radius: 50%;
      background-color: #2DB7B5;
      text-align: center;
      line-height: 54rpx;
      font-size: 40rpx;
      color: #FFF;
      margin: 0 24rpx 0 20rpx;
  }
  .order-article-body-orderitem-num.null{
      opacity: .2;
  }
  .order-article-body-orderitem-num::active {
      background-color: rgba(45,183,181,0.15);
      backface-visibility: hidden;
  }
  .order-article-body-orderitem-text{
      width: 532rpx;
      /* width: 448rpx; */
      box-sizing: border-box;
      padding-right: 44rpx;
      font-family: PingFangSC-Medium;
      font-size: 16px;
      color: #14292C;
      text-align: justify;
      line-height: 22px;
  }

</style>
